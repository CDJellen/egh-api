// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             (unknown)
// source: proto/egh-api.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// HealthServiceClient is the client API for HealthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HealthServiceClient interface {
	Health(ctx context.Context, in *HealthRequest, opts ...grpc.CallOption) (*HealthResponse, error)
}

type healthServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewHealthServiceClient(cc grpc.ClientConnInterface) HealthServiceClient {
	return &healthServiceClient{cc}
}

func (c *healthServiceClient) Health(ctx context.Context, in *HealthRequest, opts ...grpc.CallOption) (*HealthResponse, error) {
	out := new(HealthResponse)
	err := c.cc.Invoke(ctx, "/pb.HealthService/Health", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HealthServiceServer is the server API for HealthService service.
// All implementations should embed UnimplementedHealthServiceServer
// for forward compatibility
type HealthServiceServer interface {
	Health(context.Context, *HealthRequest) (*HealthResponse, error)
}

// UnimplementedHealthServiceServer should be embedded to have forward compatible implementations.
type UnimplementedHealthServiceServer struct {
}

func (UnimplementedHealthServiceServer) Health(context.Context, *HealthRequest) (*HealthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Health not implemented")
}

// UnsafeHealthServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HealthServiceServer will
// result in compilation errors.
type UnsafeHealthServiceServer interface {
	mustEmbedUnimplementedHealthServiceServer()
}

func RegisterHealthServiceServer(s grpc.ServiceRegistrar, srv HealthServiceServer) {
	s.RegisterService(&HealthService_ServiceDesc, srv)
}

func _HealthService_Health_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthServiceServer).Health(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.HealthService/Health",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthServiceServer).Health(ctx, req.(*HealthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// HealthService_ServiceDesc is the grpc.ServiceDesc for HealthService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HealthService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.HealthService",
	HandlerType: (*HealthServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Health",
			Handler:    _HealthService_Health_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/egh-api.proto",
}

// InfoServiceClient is the client API for InfoService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InfoServiceClient interface {
	ReadInfo(ctx context.Context, in *ReadInfoRequest, opts ...grpc.CallOption) (*ReadInfoResponse, error)
	ListInfo(ctx context.Context, in *ListInfoRequest, opts ...grpc.CallOption) (*ListInfoResponse, error)
	CreateInfo(ctx context.Context, in *CreateInfoRequest, opts ...grpc.CallOption) (*CreateInfoResponse, error)
	UpdateInfo(ctx context.Context, in *UpdateInfoRequest, opts ...grpc.CallOption) (*UpdateInfoResponse, error)
}

type infoServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewInfoServiceClient(cc grpc.ClientConnInterface) InfoServiceClient {
	return &infoServiceClient{cc}
}

func (c *infoServiceClient) ReadInfo(ctx context.Context, in *ReadInfoRequest, opts ...grpc.CallOption) (*ReadInfoResponse, error) {
	out := new(ReadInfoResponse)
	err := c.cc.Invoke(ctx, "/pb.InfoService/ReadInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infoServiceClient) ListInfo(ctx context.Context, in *ListInfoRequest, opts ...grpc.CallOption) (*ListInfoResponse, error) {
	out := new(ListInfoResponse)
	err := c.cc.Invoke(ctx, "/pb.InfoService/ListInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infoServiceClient) CreateInfo(ctx context.Context, in *CreateInfoRequest, opts ...grpc.CallOption) (*CreateInfoResponse, error) {
	out := new(CreateInfoResponse)
	err := c.cc.Invoke(ctx, "/pb.InfoService/CreateInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infoServiceClient) UpdateInfo(ctx context.Context, in *UpdateInfoRequest, opts ...grpc.CallOption) (*UpdateInfoResponse, error) {
	out := new(UpdateInfoResponse)
	err := c.cc.Invoke(ctx, "/pb.InfoService/UpdateInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InfoServiceServer is the server API for InfoService service.
// All implementations should embed UnimplementedInfoServiceServer
// for forward compatibility
type InfoServiceServer interface {
	ReadInfo(context.Context, *ReadInfoRequest) (*ReadInfoResponse, error)
	ListInfo(context.Context, *ListInfoRequest) (*ListInfoResponse, error)
	CreateInfo(context.Context, *CreateInfoRequest) (*CreateInfoResponse, error)
	UpdateInfo(context.Context, *UpdateInfoRequest) (*UpdateInfoResponse, error)
}

// UnimplementedInfoServiceServer should be embedded to have forward compatible implementations.
type UnimplementedInfoServiceServer struct {
}

func (UnimplementedInfoServiceServer) ReadInfo(context.Context, *ReadInfoRequest) (*ReadInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadInfo not implemented")
}
func (UnimplementedInfoServiceServer) ListInfo(context.Context, *ListInfoRequest) (*ListInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListInfo not implemented")
}
func (UnimplementedInfoServiceServer) CreateInfo(context.Context, *CreateInfoRequest) (*CreateInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateInfo not implemented")
}
func (UnimplementedInfoServiceServer) UpdateInfo(context.Context, *UpdateInfoRequest) (*UpdateInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateInfo not implemented")
}

// UnsafeInfoServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InfoServiceServer will
// result in compilation errors.
type UnsafeInfoServiceServer interface {
	mustEmbedUnimplementedInfoServiceServer()
}

func RegisterInfoServiceServer(s grpc.ServiceRegistrar, srv InfoServiceServer) {
	s.RegisterService(&InfoService_ServiceDesc, srv)
}

func _InfoService_ReadInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfoServiceServer).ReadInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.InfoService/ReadInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfoServiceServer).ReadInfo(ctx, req.(*ReadInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfoService_ListInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfoServiceServer).ListInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.InfoService/ListInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfoServiceServer).ListInfo(ctx, req.(*ListInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfoService_CreateInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfoServiceServer).CreateInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.InfoService/CreateInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfoServiceServer).CreateInfo(ctx, req.(*CreateInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfoService_UpdateInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfoServiceServer).UpdateInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.InfoService/UpdateInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfoServiceServer).UpdateInfo(ctx, req.(*UpdateInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// InfoService_ServiceDesc is the grpc.ServiceDesc for InfoService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InfoService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.InfoService",
	HandlerType: (*InfoServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReadInfo",
			Handler:    _InfoService_ReadInfo_Handler,
		},
		{
			MethodName: "ListInfo",
			Handler:    _InfoService_ListInfo_Handler,
		},
		{
			MethodName: "CreateInfo",
			Handler:    _InfoService_CreateInfo_Handler,
		},
		{
			MethodName: "UpdateInfo",
			Handler:    _InfoService_UpdateInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/egh-api.proto",
}

// ContributorsServiceClient is the client API for ContributorsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ContributorsServiceClient interface {
	ReadContributors(ctx context.Context, in *ReadContributorsRequest, opts ...grpc.CallOption) (*ReadContributorsResponse, error)
	ListContributors(ctx context.Context, in *ListContributorsRequest, opts ...grpc.CallOption) (*ListContributorsResponse, error)
	CreateContributors(ctx context.Context, in *CreateContributorsRequest, opts ...grpc.CallOption) (*CreateContributorsResponse, error)
	UpdateContributors(ctx context.Context, in *UpdateContributorsRequest, opts ...grpc.CallOption) (*UpdateContributorsResponse, error)
}

type contributorsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewContributorsServiceClient(cc grpc.ClientConnInterface) ContributorsServiceClient {
	return &contributorsServiceClient{cc}
}

func (c *contributorsServiceClient) ReadContributors(ctx context.Context, in *ReadContributorsRequest, opts ...grpc.CallOption) (*ReadContributorsResponse, error) {
	out := new(ReadContributorsResponse)
	err := c.cc.Invoke(ctx, "/pb.ContributorsService/ReadContributors", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contributorsServiceClient) ListContributors(ctx context.Context, in *ListContributorsRequest, opts ...grpc.CallOption) (*ListContributorsResponse, error) {
	out := new(ListContributorsResponse)
	err := c.cc.Invoke(ctx, "/pb.ContributorsService/ListContributors", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contributorsServiceClient) CreateContributors(ctx context.Context, in *CreateContributorsRequest, opts ...grpc.CallOption) (*CreateContributorsResponse, error) {
	out := new(CreateContributorsResponse)
	err := c.cc.Invoke(ctx, "/pb.ContributorsService/CreateContributors", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contributorsServiceClient) UpdateContributors(ctx context.Context, in *UpdateContributorsRequest, opts ...grpc.CallOption) (*UpdateContributorsResponse, error) {
	out := new(UpdateContributorsResponse)
	err := c.cc.Invoke(ctx, "/pb.ContributorsService/UpdateContributors", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ContributorsServiceServer is the server API for ContributorsService service.
// All implementations should embed UnimplementedContributorsServiceServer
// for forward compatibility
type ContributorsServiceServer interface {
	ReadContributors(context.Context, *ReadContributorsRequest) (*ReadContributorsResponse, error)
	ListContributors(context.Context, *ListContributorsRequest) (*ListContributorsResponse, error)
	CreateContributors(context.Context, *CreateContributorsRequest) (*CreateContributorsResponse, error)
	UpdateContributors(context.Context, *UpdateContributorsRequest) (*UpdateContributorsResponse, error)
}

// UnimplementedContributorsServiceServer should be embedded to have forward compatible implementations.
type UnimplementedContributorsServiceServer struct {
}

func (UnimplementedContributorsServiceServer) ReadContributors(context.Context, *ReadContributorsRequest) (*ReadContributorsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadContributors not implemented")
}
func (UnimplementedContributorsServiceServer) ListContributors(context.Context, *ListContributorsRequest) (*ListContributorsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListContributors not implemented")
}
func (UnimplementedContributorsServiceServer) CreateContributors(context.Context, *CreateContributorsRequest) (*CreateContributorsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateContributors not implemented")
}
func (UnimplementedContributorsServiceServer) UpdateContributors(context.Context, *UpdateContributorsRequest) (*UpdateContributorsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateContributors not implemented")
}

// UnsafeContributorsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ContributorsServiceServer will
// result in compilation errors.
type UnsafeContributorsServiceServer interface {
	mustEmbedUnimplementedContributorsServiceServer()
}

func RegisterContributorsServiceServer(s grpc.ServiceRegistrar, srv ContributorsServiceServer) {
	s.RegisterService(&ContributorsService_ServiceDesc, srv)
}

func _ContributorsService_ReadContributors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadContributorsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContributorsServiceServer).ReadContributors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.ContributorsService/ReadContributors",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContributorsServiceServer).ReadContributors(ctx, req.(*ReadContributorsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContributorsService_ListContributors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListContributorsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContributorsServiceServer).ListContributors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.ContributorsService/ListContributors",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContributorsServiceServer).ListContributors(ctx, req.(*ListContributorsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContributorsService_CreateContributors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateContributorsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContributorsServiceServer).CreateContributors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.ContributorsService/CreateContributors",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContributorsServiceServer).CreateContributors(ctx, req.(*CreateContributorsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContributorsService_UpdateContributors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateContributorsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContributorsServiceServer).UpdateContributors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.ContributorsService/UpdateContributors",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContributorsServiceServer).UpdateContributors(ctx, req.(*UpdateContributorsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ContributorsService_ServiceDesc is the grpc.ServiceDesc for ContributorsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ContributorsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.ContributorsService",
	HandlerType: (*ContributorsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReadContributors",
			Handler:    _ContributorsService_ReadContributors_Handler,
		},
		{
			MethodName: "ListContributors",
			Handler:    _ContributorsService_ListContributors_Handler,
		},
		{
			MethodName: "CreateContributors",
			Handler:    _ContributorsService_CreateContributors_Handler,
		},
		{
			MethodName: "UpdateContributors",
			Handler:    _ContributorsService_UpdateContributors_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/egh-api.proto",
}

// ContributionsServiceClient is the client API for ContributionsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ContributionsServiceClient interface {
	ReadContributions(ctx context.Context, in *ReadContributionsRequest, opts ...grpc.CallOption) (*ReadContributionsResponse, error)
	ListContributions(ctx context.Context, in *ListContributionsRequest, opts ...grpc.CallOption) (*ListContributionsResponse, error)
	CreateContributions(ctx context.Context, in *CreateContributionsRequest, opts ...grpc.CallOption) (*CreateContributionsResponse, error)
	UpdateContributions(ctx context.Context, in *UpdateContributionsRequest, opts ...grpc.CallOption) (*UpdateContributionsResponse, error)
}

type contributionsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewContributionsServiceClient(cc grpc.ClientConnInterface) ContributionsServiceClient {
	return &contributionsServiceClient{cc}
}

func (c *contributionsServiceClient) ReadContributions(ctx context.Context, in *ReadContributionsRequest, opts ...grpc.CallOption) (*ReadContributionsResponse, error) {
	out := new(ReadContributionsResponse)
	err := c.cc.Invoke(ctx, "/pb.ContributionsService/ReadContributions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contributionsServiceClient) ListContributions(ctx context.Context, in *ListContributionsRequest, opts ...grpc.CallOption) (*ListContributionsResponse, error) {
	out := new(ListContributionsResponse)
	err := c.cc.Invoke(ctx, "/pb.ContributionsService/ListContributions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contributionsServiceClient) CreateContributions(ctx context.Context, in *CreateContributionsRequest, opts ...grpc.CallOption) (*CreateContributionsResponse, error) {
	out := new(CreateContributionsResponse)
	err := c.cc.Invoke(ctx, "/pb.ContributionsService/CreateContributions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *contributionsServiceClient) UpdateContributions(ctx context.Context, in *UpdateContributionsRequest, opts ...grpc.CallOption) (*UpdateContributionsResponse, error) {
	out := new(UpdateContributionsResponse)
	err := c.cc.Invoke(ctx, "/pb.ContributionsService/UpdateContributions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ContributionsServiceServer is the server API for ContributionsService service.
// All implementations should embed UnimplementedContributionsServiceServer
// for forward compatibility
type ContributionsServiceServer interface {
	ReadContributions(context.Context, *ReadContributionsRequest) (*ReadContributionsResponse, error)
	ListContributions(context.Context, *ListContributionsRequest) (*ListContributionsResponse, error)
	CreateContributions(context.Context, *CreateContributionsRequest) (*CreateContributionsResponse, error)
	UpdateContributions(context.Context, *UpdateContributionsRequest) (*UpdateContributionsResponse, error)
}

// UnimplementedContributionsServiceServer should be embedded to have forward compatible implementations.
type UnimplementedContributionsServiceServer struct {
}

func (UnimplementedContributionsServiceServer) ReadContributions(context.Context, *ReadContributionsRequest) (*ReadContributionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadContributions not implemented")
}
func (UnimplementedContributionsServiceServer) ListContributions(context.Context, *ListContributionsRequest) (*ListContributionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListContributions not implemented")
}
func (UnimplementedContributionsServiceServer) CreateContributions(context.Context, *CreateContributionsRequest) (*CreateContributionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateContributions not implemented")
}
func (UnimplementedContributionsServiceServer) UpdateContributions(context.Context, *UpdateContributionsRequest) (*UpdateContributionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateContributions not implemented")
}

// UnsafeContributionsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ContributionsServiceServer will
// result in compilation errors.
type UnsafeContributionsServiceServer interface {
	mustEmbedUnimplementedContributionsServiceServer()
}

func RegisterContributionsServiceServer(s grpc.ServiceRegistrar, srv ContributionsServiceServer) {
	s.RegisterService(&ContributionsService_ServiceDesc, srv)
}

func _ContributionsService_ReadContributions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadContributionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContributionsServiceServer).ReadContributions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.ContributionsService/ReadContributions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContributionsServiceServer).ReadContributions(ctx, req.(*ReadContributionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContributionsService_ListContributions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListContributionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContributionsServiceServer).ListContributions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.ContributionsService/ListContributions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContributionsServiceServer).ListContributions(ctx, req.(*ListContributionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContributionsService_CreateContributions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateContributionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContributionsServiceServer).CreateContributions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.ContributionsService/CreateContributions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContributionsServiceServer).CreateContributions(ctx, req.(*CreateContributionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContributionsService_UpdateContributions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateContributionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContributionsServiceServer).UpdateContributions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.ContributionsService/UpdateContributions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContributionsServiceServer).UpdateContributions(ctx, req.(*UpdateContributionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ContributionsService_ServiceDesc is the grpc.ServiceDesc for ContributionsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ContributionsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.ContributionsService",
	HandlerType: (*ContributionsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReadContributions",
			Handler:    _ContributionsService_ReadContributions_Handler,
		},
		{
			MethodName: "ListContributions",
			Handler:    _ContributionsService_ListContributions_Handler,
		},
		{
			MethodName: "CreateContributions",
			Handler:    _ContributionsService_CreateContributions_Handler,
		},
		{
			MethodName: "UpdateContributions",
			Handler:    _ContributionsService_UpdateContributions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/egh-api.proto",
}

// ReadMeServiceClient is the client API for ReadMeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ReadMeServiceClient interface {
	ReadReadMe(ctx context.Context, in *ReadReadMeRequest, opts ...grpc.CallOption) (*ReadReadMeResponse, error)
	ListReadMe(ctx context.Context, in *ListReadMeRequest, opts ...grpc.CallOption) (*ListReadMeResponse, error)
	CreateReadMe(ctx context.Context, in *CreateReadMeRequest, opts ...grpc.CallOption) (*CreateReadMeResponse, error)
	UpdateReadMe(ctx context.Context, in *UpdateReadMeRequest, opts ...grpc.CallOption) (*UpdateReadMeResponse, error)
}

type readMeServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewReadMeServiceClient(cc grpc.ClientConnInterface) ReadMeServiceClient {
	return &readMeServiceClient{cc}
}

func (c *readMeServiceClient) ReadReadMe(ctx context.Context, in *ReadReadMeRequest, opts ...grpc.CallOption) (*ReadReadMeResponse, error) {
	out := new(ReadReadMeResponse)
	err := c.cc.Invoke(ctx, "/pb.ReadMeService/ReadReadMe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *readMeServiceClient) ListReadMe(ctx context.Context, in *ListReadMeRequest, opts ...grpc.CallOption) (*ListReadMeResponse, error) {
	out := new(ListReadMeResponse)
	err := c.cc.Invoke(ctx, "/pb.ReadMeService/ListReadMe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *readMeServiceClient) CreateReadMe(ctx context.Context, in *CreateReadMeRequest, opts ...grpc.CallOption) (*CreateReadMeResponse, error) {
	out := new(CreateReadMeResponse)
	err := c.cc.Invoke(ctx, "/pb.ReadMeService/CreateReadMe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *readMeServiceClient) UpdateReadMe(ctx context.Context, in *UpdateReadMeRequest, opts ...grpc.CallOption) (*UpdateReadMeResponse, error) {
	out := new(UpdateReadMeResponse)
	err := c.cc.Invoke(ctx, "/pb.ReadMeService/UpdateReadMe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReadMeServiceServer is the server API for ReadMeService service.
// All implementations should embed UnimplementedReadMeServiceServer
// for forward compatibility
type ReadMeServiceServer interface {
	ReadReadMe(context.Context, *ReadReadMeRequest) (*ReadReadMeResponse, error)
	ListReadMe(context.Context, *ListReadMeRequest) (*ListReadMeResponse, error)
	CreateReadMe(context.Context, *CreateReadMeRequest) (*CreateReadMeResponse, error)
	UpdateReadMe(context.Context, *UpdateReadMeRequest) (*UpdateReadMeResponse, error)
}

// UnimplementedReadMeServiceServer should be embedded to have forward compatible implementations.
type UnimplementedReadMeServiceServer struct {
}

func (UnimplementedReadMeServiceServer) ReadReadMe(context.Context, *ReadReadMeRequest) (*ReadReadMeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadReadMe not implemented")
}
func (UnimplementedReadMeServiceServer) ListReadMe(context.Context, *ListReadMeRequest) (*ListReadMeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListReadMe not implemented")
}
func (UnimplementedReadMeServiceServer) CreateReadMe(context.Context, *CreateReadMeRequest) (*CreateReadMeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateReadMe not implemented")
}
func (UnimplementedReadMeServiceServer) UpdateReadMe(context.Context, *UpdateReadMeRequest) (*UpdateReadMeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateReadMe not implemented")
}

// UnsafeReadMeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReadMeServiceServer will
// result in compilation errors.
type UnsafeReadMeServiceServer interface {
	mustEmbedUnimplementedReadMeServiceServer()
}

func RegisterReadMeServiceServer(s grpc.ServiceRegistrar, srv ReadMeServiceServer) {
	s.RegisterService(&ReadMeService_ServiceDesc, srv)
}

func _ReadMeService_ReadReadMe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadReadMeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReadMeServiceServer).ReadReadMe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.ReadMeService/ReadReadMe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReadMeServiceServer).ReadReadMe(ctx, req.(*ReadReadMeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReadMeService_ListReadMe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReadMeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReadMeServiceServer).ListReadMe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.ReadMeService/ListReadMe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReadMeServiceServer).ListReadMe(ctx, req.(*ListReadMeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReadMeService_CreateReadMe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateReadMeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReadMeServiceServer).CreateReadMe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.ReadMeService/CreateReadMe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReadMeServiceServer).CreateReadMe(ctx, req.(*CreateReadMeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReadMeService_UpdateReadMe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateReadMeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReadMeServiceServer).UpdateReadMe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.ReadMeService/UpdateReadMe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReadMeServiceServer).UpdateReadMe(ctx, req.(*UpdateReadMeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ReadMeService_ServiceDesc is the grpc.ServiceDesc for ReadMeService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ReadMeService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.ReadMeService",
	HandlerType: (*ReadMeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReadReadMe",
			Handler:    _ReadMeService_ReadReadMe_Handler,
		},
		{
			MethodName: "ListReadMe",
			Handler:    _ReadMeService_ListReadMe_Handler,
		},
		{
			MethodName: "CreateReadMe",
			Handler:    _ReadMeService_CreateReadMe_Handler,
		},
		{
			MethodName: "UpdateReadMe",
			Handler:    _ReadMeService_UpdateReadMe_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/egh-api.proto",
}
